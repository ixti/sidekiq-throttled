# frozen_string_literal: true
RSpec.describe Sidekiq::Throttled::Strategy do
  subject(:strategy) { described_class.new(:foo, **options) }

  let(:threshold)       { { :threshold => { :limit => 5, :period => 10 } } }
  let(:concurrency)     { { :concurrency => { :limit => 7 } } }
  let(:ten_seconds_ago) { Time.now - 10 }

  describe ".new" do
    it "fails if neither :threshold nor :concurrency given" do
      expect { described_class.new(:foo) }.to raise_error ArgumentError
    end
  end

  describe "#throttled?" do
    subject { strategy.throttled? jid }

    context "when threshold constraints given" do
      let(:options) { threshold }

      context "when limit is not yet reached" do
        before { 3.times { strategy.throttled? jid } }
        it { is_expected.to be false }
      end

      context "when limit exceeded" do
        before { 10.times { strategy.throttled? jid } }
        it { is_expected.to be true }
      end
    end

    context "when concurrency constraints given" do
      let(:options) { concurrency }

      context "when limit is not yet reached" do
        before { 6.times { strategy.throttled? jid } }
        it { is_expected.to be false }
      end

      context "when limit exceeded" do
        before { 7.times { strategy.throttled? jid } }
        it { is_expected.to be true }
      end
    end

    context "when both concurrency and threshold given" do
      let(:options) { threshold.merge concurrency }

      context "and threshold limit reached, while concurrency is not" do
        before { 5.times { strategy.throttled? jid } }
        it { is_expected.to be true }
      end

      it "avoids concurrency limit starvation" do
        Timecop.travel ten_seconds_ago do
          Array.new(4) { jid }.each do |jid|
            strategy.finalize! jid unless strategy.throttled? jid
          end
        end

        Array.new(4) { jid }.each do |jid|
          strategy.finalize! jid unless strategy.throttled? jid
        end

        expect(subject).to be false
      end

      context "and concurrency limit reached, while threshold is not" do
        before do
          Timecop.travel ten_seconds_ago do
            4.times { strategy.throttled? jid }
          end

          4.times { strategy.throttled? jid }
        end

        it { is_expected.to be true }
      end

      context "end neither concurrency nor threshold limits are reached" do
        it { is_expected.to be false }
      end
    end
  end

  describe "#reset!" do
    context "when only concurrency constraint given" do
      let(:options) { concurrency }

      specify { expect { strategy.reset! }.not_to raise_error }

      it "calls #reset! on concurrency strategy" do
        expect(strategy.concurrency).to receive(:reset!)
        strategy.reset!
      end
    end

    context "when only threshold constraint given" do
      let(:options) { threshold }

      specify { expect { strategy.reset! }.not_to raise_error }

      it "calls #reset! on threshold strategy" do
        expect(strategy.threshold).to receive(:reset!)
        strategy.reset!
      end
    end

    context "when both concurrency and threshold constraints given" do
      let(:options) { concurrency.merge threshold }

      specify { expect { strategy.reset! }.not_to raise_error }

      it "calls #reset! on concurrency strategy" do
        expect(strategy.concurrency).to receive(:reset!)
        strategy.reset!
      end

      it "calls #reset! on threshold strategy" do
        expect(strategy.threshold).to receive(:reset!)
        strategy.reset!
      end
    end
  end

  describe "#dynamic_keys?" do
    subject { strategy.dynamic_keys? }

    context "when a key_suffix is being used" do
      let(:options) { threshold.merge(:key_suffix => -> (i) { i }) }
      it { is_expected.to be_truthy }
    end

    context "when a key_suffix is not being used" do
      let(:options) { threshold }
      it { is_expected.to be_falsy }
    end
  end

  describe "#dynamic_limit?" do
    subject { strategy.dynamic_limit? }

    let(:options) { threshold }

    context "when a dynamic limit is being used" do
      let(:threshold) do
        { :threshold => { :limit => -> (i) { i }, :period => 10 } }
      end

      it { is_expected.to be_truthy }
    end

    context "when a dynamic limit is not being used" do
      let(:options) { threshold }
      it { is_expected.to be_falsy }
    end
  end
end
